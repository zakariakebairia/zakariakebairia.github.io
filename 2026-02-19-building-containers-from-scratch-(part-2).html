<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2026-02-22 Sun 22:54 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Building Containers from Scratch (Part 2)</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Zakaria Kebairia" />
<meta name="keywords" content="containers, docker, linux, namespaces, networking, veth, devops" />
<link rel="stylesheet" href="css/main.css" type="text/css" />
<header>
                <h4>
                  <a href="https://zakariakebairia.com" class="home">
                    <img src="img/home.svg" width="50" alt="Home" />
                  </a>
                  <a href="files/feed.rss" class="rss">
                    <img src="img/rss.svg" alt="RSS Feed" />
                  </a>
                  <a href="files/cv.pdf" class="resume">
                    <img src="img/cv.svg" width="40" alt="My CV" />
                  </a>
                </h4>
              </header>
</head>
<body>
<div id="content">
<h1 class="title">Building Containers from Scratch (Part 2)
<br />
<span class="subtitle">Network Isolation with Namespaces</span>
</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org969a9c0">1. Introduction</a></li>
<li><a href="#orgb6e2207">2. What We're Building</a></li>
<li><a href="#org6373e72">3. Understanding Network Namespaces</a></li>
<li><a href="#orgf230fb2">4. Building a Networked Container</a></li>
<li><a href="#org17310d1">5. Running a Service Inside the Container</a></li>
<li><a href="#org3befd4f">6. What We Achieved</a></li>
</ul>
</div>
</div>

<div id="outline-container-org969a9c0" class="outline-2">
<h2 id="org969a9c0"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
In <a href="https://zakariakebairia.com/2026-02-15-building-containers-from-scratch-(part-1).html">Part 1</a>, we built a filesystem-isolated container using <code>chroot</code>.
</p>

<p>
But our container still shares the <b>host's network stack</b>. In practice, that means two
containers can't both listen on port 80 without conflicting, the container can see host
interfaces it has no business with, and nothing stops it from binding to a port the host
is already using.
</p>

<p>
Real isolation means the container should have no idea the host's network even exists.
That's what <b>network namespaces</b> give us.
</p>
</div>
</div>

<div id="outline-container-orgb6e2207" class="outline-2">
<h2 id="orgb6e2207"><span class="section-number-2">2</span> What We're Building</h2>
<div class="outline-text-2" id="text-2">
<p>
Before diving in, here's the plan.
</p>

<ol class="org-ol">
<li>Create an isolated network namespace — a completely separate network stack living
alongside the host's.</li>
<li>Wire the two together using a <b>virtual ethernet pair</b> (veth), which acts like a
network cable connecting two isolated worlds.</li>
<li>Combine the network namespace with <code>chroot</code> to get a process with both filesystem
isolation <i>and</i> network isolation at the same time.</li>
</ol>
</div>
</div>

<div id="outline-container-org6373e72" class="outline-2">
<h2 id="org6373e72"><span class="section-number-2">3</span> Understanding Network Namespaces</h2>
<div class="outline-text-2" id="text-3">
<p>
A <b>network namespace</b> creates a completely isolated network stack. Each namespace gets
its own interfaces, IP addresses, and routing tables.
</p>

<p>
In practice: a process inside a namespace can only see and interact with the interfaces
that live in <i>its</i> namespace. No view of the host's <code>eth0</code>, no access to the host's routing
decisions — completely independent. Two processes in different namespaces can both bind
to port 80 without conflict.
</p>

<p>
Each namespace also starts with its own <code>lo</code> (loopback) interface, and can have virtual
interfaces connected to other namespaces — which is exactly how we'll wire the container
to the host.
</p>
</div>

<div id="outline-container-org2ec961a" class="outline-3">
<h3 id="org2ec961a"><span class="section-number-3">3.1</span> How the pieces fit together</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A <b>veth pair</b> is the glue. Think of it as a virtual network cable: two ends, and whatever
you send into one end comes out the other. We put one end in the host namespace and one
end in the container namespace — that's our communication channel between the two isolated
worlds.
</p>


<div class="figure">
<p><img src="img/blogs/container_from_scratch/part2/netns.gif" alt="Network namespace diagram" width="1000" align="center" class="diagram" />
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf230fb2" class="outline-2">
<h2 id="orgf230fb2"><span class="section-number-2">4</span> Building a Networked Container</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-org7ea47f6" class="outline-3">
<h3 id="org7ea47f6">Prerequisites</h3>
<div class="outline-text-3" id="text-org7ea47f6">
<p>
Make sure you have the <code>my_container</code> directory from <a href="https://zakariakebairia.com/2026-02-15-building-containers-from-scratch-(part-1).html">Part 1</a>.
</p>
</div>
</div>

<div id="outline-container-org0a2bea0" class="outline-3">
<h3 id="org0a2bea0">Step 1: Create a Network Namespace</h3>
<div class="outline-text-3" id="text-org0a2bea0">
<div class="org-src-container">
<pre class="src src-bash">sudo ip netns add container_net
</pre>
</div>

<p>
Verify the namespace was created:
</p>

<div class="org-src-container">
<pre class="src src-bash">ip netns list
</pre>
</div>

<pre class="example">
container_net
</pre>
</div>
</div>

<div id="outline-container-orgcb1fb96" class="outline-3">
<h3 id="orgcb1fb96">Step 2: Create a Virtual Ethernet Pair</h3>
<div class="outline-text-3" id="text-orgcb1fb96">
<p>
Now we create the virtual cable. Both ends land in the host namespace for now.
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip link add veth-host type veth peer name veth-container
</pre>
</div>

<p>
Verify both interfaces exist:
</p>

<div class="org-src-container">
<pre class="src src-bash">ip link show | grep veth
</pre>
</div>

<pre class="example">
6: veth-container@veth-host: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500
7: veth-host@veth-container: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500
</pre>

<p>
Both are in the <b>host namespace</b> and currently down.
</p>
</div>
</div>

<div id="outline-container-org99df1d9" class="outline-3">
<h3 id="org99df1d9">Step 3: Move One End into the Container Namespace</h3>
<div class="outline-text-3" id="text-org99df1d9">
<div class="org-src-container">
<pre class="src src-bash">sudo ip link set veth-container netns container_net
</pre>
</div>

<p>
Verify <code>veth-container</code> is gone from the host:
</p>

<div class="org-src-container">
<pre class="src src-bash">ip link show | grep veth
</pre>
</div>

<pre class="example">
7: veth-host@if6: &lt;BROADCAST,MULTICAST&gt; mtu 1500
</pre>

<p>
And verify it exists inside the namespace:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ip link show
</pre>
</div>

<pre class="example">
1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN
6: veth-container@if7: &lt;BROADCAST,MULTICAST&gt; mtu 1500
</pre>

<div class="callout_note">
<p>
The namespace now has two interfaces: <code>lo</code> (loopback) and <code>veth-container</code>. Both are
currently down.
</p>

</div>

<div class="callout_note">
<p>
You can run commands inside a network namespace with <code>ip netns exec &lt;namespace&gt; &lt;command&gt;</code>.
We'll use this heavily when combining the namespace with <code>chroot</code>.
</p>

</div>
</div>
</div>

<div id="outline-container-orgd6d7f02" class="outline-3">
<h3 id="orgd6d7f02">Step 4: Configure the Host Side</h3>
<div class="outline-text-3" id="text-orgd6d7f02">
<p>
Assign an IP address and bring the interface up:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip addr add 192.168.10.1/24 dev veth-host
sudo ip link set veth-host up
</pre>
</div>

<p>
Verify:
</p>

<div class="org-src-container">
<pre class="src src-bash">ip addr show veth-host
</pre>
</div>

<pre class="example">
7: veth-host@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500
    inet 192.168.10.1/24 scope global veth-host
</pre>
</div>
</div>

<div id="outline-container-orgb8a392f" class="outline-3">
<h3 id="orgb8a392f">Step 5: Configure the Container Side</h3>
<div class="outline-text-3" id="text-orgb8a392f">
<p>
First, bring up the loopback interface:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ip link set lo up
</pre>
</div>

<p>
Then configure the container's interface:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ip addr add 192.168.10.2/24 dev veth-container
sudo ip netns exec container_net ip link set veth-container up
</pre>
</div>

<p>
Verify:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ip addr show
</pre>
</div>

<pre class="example">
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536
    inet 127.0.0.1/8 scope host lo
6: veth-container@if7: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500
    inet 192.168.10.2/24 scope global veth-container
</pre>
</div>
</div>

<div id="outline-container-orgac3f266" class="outline-3">
<h3 id="orgac3f266">Step 6: Test Network Connectivity</h3>
<div class="outline-text-3" id="text-orgac3f266">
<p>
From the host, ping the container:
</p>

<div class="org-src-container">
<pre class="src src-bash">ping -c 3 192.168.10.2
</pre>
</div>

<pre class="example">
PING 192.168.10.2 (192.168.10.2) 56(84) bytes of data.
64 bytes from 192.168.10.2: icmp_seq=1 ttl=64 time=0.053 ms
64 bytes from 192.168.10.2: icmp_seq=2 ttl=64 time=0.042 ms
64 bytes from 192.168.10.2: icmp_seq=3 ttl=64 time=0.039 ms
</pre>

<p>
From the container namespace, ping the host:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ping -c 3 192.168.10.1
</pre>
</div>

<pre class="example">
PING 192.168.10.1 (192.168.10.1) 56(84) bytes of data.
64 bytes from 192.168.10.1: icmp_seq=1 ttl=64 time=0.041 ms
64 bytes from 192.168.10.1: icmp_seq=2 ttl=64 time=0.038 ms
64 bytes from 192.168.10.1: icmp_seq=3 ttl=64 time=0.037 ms
</pre>

<p>
The two namespaces can talk to each other.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>
</div>
</div>
</div>

<div id="outline-container-org17310d1" class="outline-2">
<h2 id="org17310d1"><span class="section-number-2">5</span> Running a Service Inside the Container</h2>
<div class="outline-text-2" id="text-5">
<p>
So far, the network namespace and the chroot environment have been two separate things.
Now we bring them together.
</p>

<p>
The command below drops into a shell that is simultaneously locked into <code>my_container</code>'s
filesystem <i>and</i> placed inside the <code>container_net</code> network namespace. Filesystem isolation
and network isolation, at the same time — and what you get starts looking a lot like an
actual container.
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net chroot my_container /bin/bash
</pre>
</div>

<p>
You're now inside a process that can't see the host filesystem and can't see the host network.
</p>

<p>
Let's simulate an HTTP server running on port 8080:
</p>

<div class="org-src-container">
<pre class="src src-bash"><span style="font-weight: bold;">echo</span> -e <span style="font-style: italic;">"HTTP/1.1 200 OK\r\n\r\nHello from the Container!"</span> | nc -l -p 8080
</pre>
</div>

<p>
The server is listening on port <b>8080</b> — but only inside the container's network namespace.
</p>
</div>

<div id="outline-container-org215e454" class="outline-3">
<h3 id="org215e454">Verify Isolation</h3>
<div class="outline-text-3" id="text-org215e454">
<p>
From the host, check listening ports:
</p>

<div class="org-src-container">
<pre class="src src-bash">ss -tlnp | grep 8080
</pre>
</div>

<pre class="example">
(no output)
</pre>

<p>
Port 8080 is <b>not</b> visible on the host's network stack — it only exists inside the
container namespace.<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>
</div>
</div>

<div id="outline-container-org499638f" class="outline-3">
<h3 id="org499638f">Test from the Host</h3>
<div class="outline-text-3" id="text-org499638f">
<p>
In another terminal:
</p>

<div class="org-src-container">
<pre class="src src-bash">curl http://192.168.10.2:8080
</pre>
</div>

<pre class="example">
Hello from the Container!
</pre>

<p>
And voilà.
</p>
</div>
</div>

<div id="outline-container-org31998f0" class="outline-3">
<h3 id="org31998f0">Connecting to the Outside World&#xa0;&#xa0;&#xa0;<span class="tag"><span class="optional">optional</span></span></h3>
<div class="outline-text-3" id="text-org31998f0">
<p>
The container can talk to the host, but it's blind to the internet. To fix that, we need
two things: a default route so the container knows where to send traffic, and masquerading <sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>
on the host so packets can leave with a routable source address.
</p>

<p>
Add a default route inside the container namespace, pointing to the host:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ip route add default via 192.168.10.1 dev veth-container
</pre>
</div>

<p>
Verify the routing table:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ip route show
</pre>
</div>

<pre class="example">
default via 192.168.10.1 dev veth-container
192.168.10.0/24 dev veth-container proto kernel scope link src 192.168.10.2
</pre>

<p>
Before masquerading can work, the host needs to forward packets between interfaces 
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo sysctl -w net.ipv4.ip_forward=1
</pre>
</div>

<p>
Enable masquerading<sup><a id="fnr.3.100" class="footref" href="#fn.3">3</a></sup> on the host so outgoing packets get a valid source IP:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo firewall-cmd --add-masquerade
</pre>
</div>

<pre class="example">
success
</pre>

<p>
Ping <code>8.8.8.8</code> from inside the container:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ping -c 3 8.8.8.8
</pre>
</div>

<pre class="example">
PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.
64 bytes from 8.8.8.8: icmp_seq=1 ttl=113 time=14.2 ms
64 bytes from 8.8.8.8: icmp_seq=2 ttl=113 time=13.8 ms
64 bytes from 8.8.8.8: icmp_seq=3 ttl=113 time=14.1 ms

--- 8.8.8.8 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2003ms
rtt min/avg/max/mdev = 13.8/14.0/14.2/0.183 ms
</pre>

<p>
We're online. Now try a domain name:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ping -c 1 google.com
</pre>
</div>

<pre class="example">
ping: google.com: Temporary failure in name resolution
</pre>

<p>
Makes sense — the namespace has no DNS configured. The container's <code>/etc/resolv.conf</code> is
empty, so it has nowhere to ask. Fix it:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net bash -c <span style="font-style: italic;">'echo "nameserver 8.8.8.8" &gt; /etc/resolv.conf'</span>
</pre>
</div>

<p>
Now try again:
</p>

<div class="org-src-container">
<pre class="src src-bash">sudo ip netns exec container_net ping -c 3 google.com
</pre>
</div>

<pre class="example">
PING google.com (142.250.185.46) 56(84) bytes of data.
64 bytes from lga34s32-in-f14.1e100.net (142.250.185.46): icmp_seq=1 ttl=113 time=15.1 ms
64 bytes from lga34s32-in-f14.1e100.net (142.250.185.46): icmp_seq=2 ttl=113 time=14.7 ms
64 bytes from lga34s32-in-f14.1e100.net (142.250.185.46): icmp_seq=3 ttl=113 time=14.9 ms

--- google.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2003ms
rtt min/avg/max/mdev = 14.7/14.9/15.1/0.163 ms
</pre>

<p>
Fully connected.<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>
</p>
</div>
</div>
</div>

<div id="outline-container-org3befd4f" class="outline-2">
<h2 id="org3befd4f"><span class="section-number-2">6</span> What We Achieved</h2>
<div class="outline-text-2" id="text-6">
<p>
We started with a container that isolated the filesystem but left the network completely
exposed. Now it has its own interfaces, its own IP address, its own routing table, and
isolated ports — and it can reach the internet.
</p>

<p>
But the container can still consume as much CPU and memory as it wants, and bring the host
to its knees. That's what Part 3 is about.
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
If ping fails, check that both interfaces are UP, IP addresses are correctly assigned, and
the firewall isn't blocking ICMP.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
This is what makes multi-tenant environments possible. Containers can all listen on port 80
without conflict because each lives in its own network namespace.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
The container's source IP (<code>192.168.10.2</code>) is private — routers on the internet won't know how to reply to it. Masquerading rewrites that source IP to the host's public IP as packets leave, and translates replies back on the way in.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
If you're using <code>chroot</code> alongside the network namespace, the container's <code>/etc/resolv.conf</code>
lives at <code>my_container/etc/resolv.conf</code> on the host filesystem — you may want to write
there directly instead.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">

<p class="postamble">
  <a href="http://creativecommons.org/licenses/by-sa/4.0/" class="crc">
    <img src="img/crc.png" alt="Creative Commons License" />
  </a>

  <a href="https://www.linkedin.com/in/zakaria-kebairia/" class="social">
    <img src="img/social/linkedin-icon-logo.svg" width="45" alt="LinkedIn" />
  </a>

  <a href="https://twitter.com/z_kebairia" class="social">
    <img src="img/social/twitter-logo.svg" width="40" alt="Twitter" />
  </a>

  <a href= "https://www.youtube.com/@zakariakebairia" class="social">
    <img src="img/social/youtube-black-logo.svg" width="40" alt="YouTube" />
  </a>

  <a href="https://www.github.com/zakariakebairia" class="social">
    <img src="img/social/github.svg" width="43" alt="GitHub" />
  </a>

  <br>

  <p class="credit">
    Copyright &copy; 2026 Zakaria Kebairia
    <br>
    Content licensed under <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a> unless otherwise noted.
  </p>
</p>
</div>
</body>
</html>
